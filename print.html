<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Geo-AID Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">2.</strong> Beginner guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/getting-started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="guide/complicated-figures.html"><strong aria-hidden="true">2.2.</strong> Dealing with complicated figures</a></li></ol></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">3.</strong> CLI Reference</a></li><li class="chapter-item expanded "><a href="formats.html"><strong aria-hidden="true">4.</strong> Formats</a></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">5.</strong> GeoScript reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/syntax.html"><strong aria-hidden="true">5.1.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/syntax/properties.html"><strong aria-hidden="true">5.1.1.</strong> Properties</a></li><li class="chapter-item expanded "><a href="reference/syntax/expressions.html"><strong aria-hidden="true">5.1.2.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="reference/syntax/figure.html"><strong aria-hidden="true">5.1.3.</strong> Figure</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.4.</strong> Flags</div></li><li class="chapter-item expanded "><a href="reference/syntax/identifiers.html"><strong aria-hidden="true">5.1.5.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="reference/syntax/iterators.html"><strong aria-hidden="true">5.1.6.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="reference/syntax/names.html"><strong aria-hidden="true">5.1.7.</strong> Names</a></li><li class="chapter-item expanded "><a href="reference/syntax/numbers.html"><strong aria-hidden="true">5.1.8.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="reference/syntax/properties.html"><strong aria-hidden="true">5.1.9.</strong> Properties</a></li><li class="chapter-item expanded "><a href="reference/syntax/refs.html"><strong aria-hidden="true">5.1.10.</strong> Ref statements</a></li><li class="chapter-item expanded "><a href="reference/syntax/rules.html"><strong aria-hidden="true">5.1.11.</strong> Rules</a></li><li class="chapter-item expanded "><a href="reference/syntax/variables.html"><strong aria-hidden="true">5.1.12.</strong> Variables</a></li></ol></li><li class="chapter-item expanded "><a href="reference/types.html"><strong aria-hidden="true">5.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/types/primitives.html"><strong aria-hidden="true">5.2.1.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="reference/types/bundle-types.html"><strong aria-hidden="true">5.2.2.</strong> Bundle types</a></li></ol></li><li class="chapter-item expanded "><a href="reference/operators.html"><strong aria-hidden="true">5.3.</strong> Operators</a></li><li class="chapter-item expanded "><a href="reference/functions.html"><strong aria-hidden="true">5.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/rule-operators.html"><strong aria-hidden="true">5.5.</strong> Rule operators</a></li><li class="chapter-item expanded "><a href="reference/display-system.html"><strong aria-hidden="true">5.6.</strong> Display system</a></li><li class="chapter-item expanded "><a href="reference/weight-system.html"><strong aria-hidden="true">5.7.</strong> Weight system</a></li></ol></li><li class="chapter-item expanded "><a href="https://www.overleaf.com/read/nnjqztpynydm#156b73.html"><strong aria-hidden="true">6.</strong> Math behind Geo-AID</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Geo-AID Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/logo.svg" alt="Geo-AID logo" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Geo-AID is a tool to generate figures based off of rules given in the script file. Its main purpose is to minimize the
pain related to drawing figures for certain mathematical problems or theorems. It's currently in the early development.</p>
<blockquote>
<p><strong>Note:</strong> Geo-AID is not designed to produce <em>perfect</em> output. It is designed to produce <em>best</em> output. This means
that it might sacrifice partial accuracy in favor of better readability. It may also make other compromises and produce
unexpected results at times. If you're having trouble with this kind of behavior,
visit <a href="./guide/complicated-figures.html">Dealing with complicated figures</a></p>
</blockquote>
<p>As an entry point, Geo-AID uses GeoScript - a language used to describe a figure. Aside from that, special parameters
can be set as command line arguments. This book is meant to serve as a guide to anyone starting to use Geo-AID and as a
reference to anyone who wants to know more.</p>
<blockquote>
<p><strong>Note:</strong> This book is held up-do-date with the latest released version
on <a href="https://crates.io/crates/geo-aid">crates.io</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginner-guide"><a class="header" href="#beginner-guide">Beginner guide</a></h1>
<p>This guide will get you through your first steps with Geo-AID. You will install the tool (if you haven't already) and create your first figure. Then, you will learn how to deal with figures that require distances and how to use Geo-AID parameters to your advantage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Before you start using Geo-AID, you'll need to install it. Unfortunately, it does not come in the form of precompiled
binaries, and you'll need some other tools to build it. First, <a href="https://www.rust-lang.org/">install Rust and Cargo</a>.
Once you're done, there are two ways of setting up Geo-AID:</p>
<p>The first way is to simply use the <code>cargo install</code> method:</p>
<pre><code class="language-shell">cargo install geo-aid
</code></pre>
<p>This has the advantage of installing Geo-AID globally, so that you can run it from anywhere. It will take care of all
dependencies for you. Building may take some time, but once it's done, it's done for good (unless you'll want to update
it).</p>
<p>The second way is to clone/download the <a href="https://github.com/DragonGamesStudios/Geo-AID/tree/v0.2">GitHub repository</a> (
remember to get the last vX.X version) and build Geo-AID yourself. In this, case, you will also need
the <a href="https://github.com/DragonGamesStudios/geo_aid_derive">geo_aid_derive</a> source. To download the repos, you'll need to
download the .zip file and unpack it somewhere. If you want to clone it (recommended), you'll
need <a href="https://git-scm.com/">git</a>. The clone way is shown below</p>
<pre><code class="language-shell">mkdir geo-aid
cd geo-aid
git clone https://github.com/DragonGamesStudios/Geo-AID.git
git clone https://github.com/DragonGamesStudios/geo_aid_derive.git
cd Geo-AID
git checkout v0.2
</code></pre>
<p>It's important that if you compile from source, you should preserve this file structure:</p>
<pre><code>| some_folder:
    | geo-aid
    | geo_aid_derive
</code></pre>
<p>Then, either build it with <code>cargo build --release</code> and use the produced executable or run it with
<code>cargo run --release -- &lt;geo-aid arguments here&gt;</code>.</p>
<p>Run the program with the <code>--version</code> flag to check if it works properly. You can also run <code>geo-aid --help</code> (replace
<code>geo-aid</code> with <code>cargo run --release --</code> if using the second way) if you want to see how to use the tool CLI (you can
also check the <a href="guide/../cli.html">CLI reference</a>).</p>
<p>The rest of this book will assume you have the command globally available (as if it was installed).</p>
<h2 id="your-first-figure"><a class="header" href="#your-first-figure">Your first figure</a></h2>
<p>In order to use Geo-AID, we have to tell it exactly what we want. We can do this with a script file. Geo-AID uses a
special language called GeoScript that lets us give specific instructions. Create the following file with a name of your
choice, say <code>figure.geo</code>:</p>
<pre><code>let A = Point();
let B = Point();
let C = Point();

AB = AC;
AB = BC;
</code></pre>
<p>and run it with the following command:</p>
<pre><code class="language-shell">geo-aid figure.geo figure.svg
</code></pre>
<p>After a short wait a new file <code>figure.svg</code> should show up. Open it in any SVG previewer (could even be your browser) and
gaze at your first figure in awe:</p>
<p><img style="background-color: white;" src="guide/first-figure.svg" alt="An equilateral triangle ABC"></p>
<p>Ok, but what exactly happened here? Let's take a closer look at the script we've just given to Geo-AID:</p>
<p>First, we have the three <code>let</code> statements. These statements are used to create variables. In our case, these variables
are points created with the <code>Point()</code> function. You can also add special display properties to the variable definitions
to change how they are rendered. For example, if you change the first line to the following:</p>
<pre><code>let A [label = G] = Point();
</code></pre>
<p>you should get something like this:</p>
<p><img style="background-color: white;" src="guide/renamed-a.svg" alt="An equilateral triangle BCG"></p>
<p>You can find out more about the display system <a href="guide/../reference/display-system.html">here</a>.</p>
<p>After the variable definitions, we have the two lines:</p>
<pre><code>AB = AC;
AB = BC;
</code></pre>
<p>These are called rule statements. They represent a relationship between the left hand side and the right hand side. In
this case, the relationship is the equality of lengths AB, BC and AC. It's worth noting that the equality sign
represents a <em>rule</em>, not a <em>definition</em> or a <em>redefinition</em>. GeoScript is a description language, not a programming one.</p>
<p>Geo-AID takes these requirements and attempts to create a figure that meets them.</p>
<p><code>let</code> statements and rules can be sometimes combined by adding rules <em>after</em> the left hand side of a <code>let</code> statement.
For example:</p>
<pre><code># This is a comment
let A = Point();
let B = Point();
let C = Point();
let r = dst(BC) &lt; AB;

let omega = Circle(A, r);
</code></pre>
<p>Here, <code>r</code> is set to the distance <code>BC</code> and said to be smaller than <code>AB</code>.</p>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Geo-AID mostly operates on expressions. They are variable definitions and both sides of rules. Expressions can be
mathematical operations, function calls, lines, distances and literals. All expressions produce values of certain types.
These can be divided into the following categories:</p>
<ul>
<li>primitives</li>
<li>point collections</li>
<li>bundle types</li>
</ul>
<p>Primitives are points, lines, circles and scalars. They're what the generator operates on and what everything is
ultimately compiled into. Everything else is just an abstraction over these primitives. Additionally, scalars can have
units. Performing addition or subtraction on scalars with incompatible units is an error.</p>
<p>Point collections are sequences of point letters, like <code>AB</code>, <code>ABC</code>, <code>GFED</code>, <code>X</code>, <code>A'V</code>. For a name to be collectable, it
has to be a single, uppercase letter with an arbitrary number of ticks (<code>'</code>) following it, that represents a point.
Point collections can also be constructed using <code>&amp;(...)</code> syntax. You can use them on the left-hand side of <code>let</code>
statements to unpack the rhs expression onto a point collection. Note, however, that not all types have that option.</p>
<pre><code>let ABC = &amp;(intersection(XY, GH), mid(G, H), intersection(TU, KL));
</code></pre>
<p>Bundle types are essentially like structs in programming languages. They have their primitive fields and functions
defined on them that can be used for more comfortable workflow.</p>
<h3 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h3>
<p>Geo-AID is capable of performing some implicit conversions:</p>
<ul>
<li>Unknown-unit scalars (usually literals) can be converted into a scalar with a distance unit.</li>
<li>A point collection consisting of two points can be converted into a line or the distance between the two points,
depending on the context.</li>
<li>A point collection of length one is always automatically converted into a point.</li>
<li>When performing multiplication/division over a scalar with a unit and a scalar with an unknown unit, the latter is
automatically converted into a unitless scalar (standard scalar in mathematics).</li>
<li>Any variable defined with an unknown-unit scalar is assumed to be unit-less.</li>
</ul>
<h2 id="shortening-the-code-with-iterators"><a class="header" href="#shortening-the-code-with-iterators">Shortening the code with iterators</a></h2>
<p>Many figures feature multiple points and defining each one with a separate <code>let</code> statement can feel very verbose. To
help that, GeoScript has a powerful iterator system. Iterators can be used in <code>let</code> statements and rules on both sides.
A sequence of expressions separated by a comma is called an <em>implicit iterator</em>. Using these, we can collapse multiple
lines of a script into a single one. For example, our first figure script becomes the following:</p>
<pre><code>let A, B, C = Point();

AB = AC, BC;
</code></pre>
<p>Iterators are expanded into multiple rules/statement by simply iterating over the given sequence. Note that implicit
iterators take precedence over binary arithmetic operators. Here's a few examples:</p>
<pre><code>AB, BC = CD, EF;

# Becomes
AB = CD;
BC = EF;
</code></pre>
<pre><code>AB &lt; XY + YZ, OI;

# Becomes.
AB &lt; XY + YZ;
AB &lt; XY + OI;
</code></pre>
<p>whereas</p>
<pre><code>AB &lt; (XY + YZ), OI;

# Becomes

AB &lt; XY + YZ;
AB &lt; OI;
</code></pre>
<p>To use implicit iterators inside a function call, simply put parentheses around them: <code>intersection(AB, (KL, XY))</code></p>
<p>Another type of iterator is an <em>explicit iterator</em>. These are written in the following way:</p>
<pre><code>AB = $1(AC, BC);
</code></pre>
<p>The above example is equivalent to just writing</p>
<pre><code>AB = AC, BC;
</code></pre>
<p>The number after the dollar sign is the <em>id</em> of the iterator. If you're using a single id, they function just like
implicit iterators. However, when using multiple different ids, you can get some interesting results:</p>
<pre><code>$1(AB, CD) &lt; $2(XY, YZ);

# Becomes
AB &lt; XY;
CD &lt; XY;
AB &lt; YZ;
CD &lt; YZ;
</code></pre>
<p>Explicit iterators can also be nested, allowing for even more complicated rules. For example:</p>
<pre><code>$1(AB, BC) &gt; $1(x, $2(a, b)), $3(9, 4, 3);

# Becomes
AB &gt; x;
BC &gt; a;
BC &gt; b;
AB &gt; 9;
AB &gt; 4;
AB &gt; 3;
BC &gt; 9;
BC &gt; 4;
BC &gt; 3;
</code></pre>
<p>There are a few important things to remember about iterators:</p>
<ul>
<li>All implicit iterators have an id of 0;</li>
<li>All iterators of the same id must have the same length;</li>
<li>The left hand side of <code>let</code> statements only accept implicit iterators;</li>
<li>The right hand side of <code>let</code> statements accepts at most one level of iteration;</li>
<li>The right hand side of a <code>let</code> statement may only contain iterators, if so does the left side;</li>
<li>All iterators must have at least two variants;</li>
<li>An iterator with id x must not contain another iterator with id x;</li>
<li>Iterator length must not exceed 255;</li>
<li>Iterator id must be an integer;</li>
</ul>
<p>Exact rules regarding the iterators can be found <a href="guide/../reference/syntax/iterators.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealing-with-complicated-figures"><a class="header" href="#dealing-with-complicated-figures">Dealing with complicated figures</a></h1>
<p>Sometimes you will stumble on a figure that is quite challenging to draw, even for Geo-AID. In these cases, it's worth
knowing a few tricks to guide Geo-AID through them.</p>
<p>When Geo-AID generates a figure, it does so with a certain amount of samples, over multiple cycles, until a certain
condition (currently: average quality delta over the last x cycles goes below a certain value) is met. That's a lot of
different generation parameters and all of them are modifiable.</p>
<ol>
<li>Sample count (<code>-s</code> or <code>--samples</code> option, 512 by default)</li>
</ol>
<p>By modifying this parameter, you change how many different versions of a generation cycle are created. The higher the
value, the more likely Geo-AID is to find the right spot for every point. It will, however, take more time, and it might
make certain flaws of Geo-AID's generation more visible.</p>
<ol start="2">
<li>Generation break average delta threshold (<code>-d</code> option, 0.0001 by default)</li>
</ol>
<p>Lowering this makes Geo-AID go on with generation for a little longer, essentially postponing the moment it decides it
won't really get much better.</p>
<ol start="3">
<li>Count of last records used in calculating the average delta (<code>-m</code> option, 128 by default)</li>
</ol>
<p>Increasing this makes Geo-AID take more of the last cycles into consideration when deciding whether to stop.</p>
<ol start="4">
<li>Generation engine (<code>-e</code> or <code>--engine</code>, <code>glide</code> by default)</li>
</ol>
<p>By default, Geo-AID uses <code>glide</code> as its optimization engine as it should generally perform better than <code>rage</code>. It might,
however, be worth a try to switch the engine.</p>
<ol start="5">
<li>Maximum adjustment per generation cycle (<code>-a</code> option, 0.5 by default)</li>
</ol>
<p>This modifies how much can a single point/scalar be changed when adjusting for another cycle. Keep in mind that this is
only a base for calculations. In reality, the amount of adjustment allowed depends on the given point's quality and is
different between different workers to allow both big <em>and</em> small changes in the same generation cycle. This parameter
only works with the Rage engine.</p>
<hr />
<p>Usually, the most visible effect comes from increasing the sample count.</p>
<p>Ultimately the best way of increasing odds for Geo-AID is to write the script as well as you can, relying strongly on
defining points with expressions. The golden rule is: the fewer rules, the better.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface-of-geo-aid"><a class="header" href="#command-line-interface-of-geo-aid">Command-Line Interface of Geo-AID</a></h1>
<p><strong>Command Overview:</strong></p>
<ul>
<li><a href="cli.html#Geo-AID"><code>Geo-AID</code></a></li>
</ul>
<h2 id="geo-aid"><a class="header" href="#geo-aid"><code>Geo-AID</code></a></h2>
<p><strong>Usage:</strong> <code>Geo-AID [OPTIONS] &lt;INPUT&gt; &lt;OUTPUT&gt;</code></p>
<h6 id="arguments"><a class="header" href="#arguments"><strong>Arguments:</strong></a></h6>
<ul>
<li><code>&lt;INPUT&gt;</code> — The input script file</li>
<li><code>&lt;OUTPUT&gt;</code> — The output target</li>
</ul>
<h6 id="options"><a class="header" href="#options"><strong>Options:</strong></a></h6>
<ul>
<li>
<p><code>-d</code>, <code>--delta-max-mean &lt;DELTA_MAX_MEAN&gt;</code> — The maximum mean quality delta. Geo-AID will keep doing generation cycles
until the average quality delta over the last <code>m</code> cycles gets below <code>d</code>.</p>
<p>Default value: <code>0.0001</code></p>
</li>
<li>
<p><code>-w</code>, <code>--worker-count &lt;WORKER_COUNT&gt;</code> — The count of threads to use for generation</p>
<p>Default value: <code>32</code></p>
</li>
<li>
<p><code>-s</code>, <code>--samples</code> - The count of samples to use for generation. Each engine interprets it differently</p>
<p>Default value: <code>512</code></p>
</li>
<li>
<p><code>-e</code>, <code>--engine</code> - The generation engine to use.</p>
<p>Default value: <code>glide</code></p>
<p>Possible values:</p>
<ul>
<li><code>glide</code>:
The gradient descent engine</li>
<li><code>rage</code>:
Random adjustment based engine</li>
</ul>
</li>
<li>
<p><code>-m</code>, <code>--mean-count &lt;MEAN_COUNT&gt;</code> — The count of last deltas to include in mean calculation. Geo-AID will keep doing
generation cycles until the average quality delta over the last <code>m</code> cycles gets below <code>d</code>.</p>
<p>Default value: <code>128</code></p>
</li>
<li>
<p><code>-s</code>, <code>--strictness &lt;STRICTNESS&gt;</code> — How strict the generator treats the rules. The higher, the more strict. Can't be
zero.</p>
<p>Default value: <code>2.0</code></p>
</li>
<li>
<p><code>-a</code>, <code>--adjustment-max &lt;ADJUSTMENT_MAX&gt;</code> — Maximal adjustment of an adjustable during generation. Treated differently
for different adjustables.</p>
<p>Default value: <code>0.5</code></p>
</li>
<li>
<p><code>-r</code>, <code>--renderer &lt;RENDERER&gt;</code> — What renderer to use.</p>
<p>Default value: <code>svg</code></p>
<p>Possible values:</p>
<ul>
<li><code>latex</code>:
The LaTeX + tikz renderer</li>
<li><code>svg</code>:
The SVG format renderer</li>
<li><code>json</code>:
The JSON (machine-readable) format renderer</li>
<li><code>raw</code>:
The raw (human-readable) format renderer</li>
</ul>
</li>
<li>
<p><code>--width &lt;WIDTH&gt;</code> — Canvas width (treated very differently for LaTeX)</p>
<p>Default value: <code>500</code></p>
</li>
<li>
<p><code>--height &lt;HEIGHT&gt;</code> — Canvas height (treated very differently for LaTeX)</p>
<p>Default value: <code>500</code></p>
</li>
<li>
<p><code>-l</code>, <code>--log &lt;LOG&gt;</code> — Where to put the log output. Geo-AID has a logging feature for concise information about the
rendering process (quality and time).</p>
</li>
</ul>
<hr/>
<p><small><i>
This document was generated with the help of
<a href="https://crates.io/crates/clap-markdown"><code>clap-markdown</code></a>.
</i></small></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renderers"><a class="header" href="#renderers">Renderers</a></h1>
<p>Geo-AID supports four different renderers, also called drawers. One more is planned.</p>
<h2 id="latex"><a class="header" href="#latex">LaTeX</a></h2>
<p>Using <a href="https://www.latex-project.org/"><code>LaTeX</code></a>, <a href="https://www.overleaf.com/learn/latex/TikZ_package"><code>tikz</code></a> and <a href="https://ctan.org/pkg/tkz-euclide">
<code>tikz-euclide</code></a>, one of the two recommended ways of drawing the figure.</p>
<h2 id="svg"><a class="header" href="#svg">SVG</a></h2>
<p>Outputs the figure in the <a href="https://developer.mozilla.org/en-US/docs/Web/SVG"><code>svg</code></a> format. One of the two - and the
most tested - ways of drawing the figure.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>Machine-readable <a href="https://www.json.org/json-en.html">JSON</a> format according to the Schema available in Geo-AID's
repository. Can be used to integrate other tools with Geo-AID.</p>
<h2 id="raw"><a class="header" href="#raw">Raw</a></h2>
<p>A human-readable format, pure <a href="https://en.wikipedia.org/wiki/Plain_text">text</a>. Contains descriptions of the positions
of each object in the figure.</p>
<h2 id="geogebra"><a class="header" href="#geogebra">GeoGebra</a></h2>
<p>Work in progress, Geo-AID will support outputting in the GeoGebra format importable in the very tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geoscript-reference"><a class="header" href="#geoscript-reference">GeoScript reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>This chapter describes the syntax of GeoScript. The notation used is the same as defined in <a href="https://doc.rust-lang.org/reference/notation.html">The Rust Reference</a>. Geo-AID expects utf8 encoded files. All whitespaces are ignored beyond distinguishing separate tokens. The basis is the <em>Figure</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties"><a class="header" href="#properties">Properties</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>Properties</em> :<br />
   <code>[</code> <em>Property</em> (<code>;</code> <em>Property</em>)<sup>*</sup> <code>]</code><br />
<br />
<em>Property</em> :<br />
   <a href="reference/syntax/identifiers.html">NAMED_IDENT</a> <code>=</code> <em>PropertyValue</em><br />
<br />
<em>PropertyValue</em> :<br />
      <a href="reference/syntax/numbers.html">NUMBER</a><br />
   | <a href="reference/syntax/identifiers.html">IDENT</a><br />
   | STRING<br />
   | <em>RawString</em><br />
<br />
<em>RawString</em> :<br />
   <code>!</code> STRING</p>
</blockquote>
<h2 id="property-values"><a class="header" href="#property-values">Property values</a></h2>
<h3 id="bool"><a class="header" href="#bool"><code>bool</code></a></h3>
<p>Boolean properties represent true or false for certain properties. A true value can be represented as the following:</p>
<pre><code>1, true, enabled, on, "true", "enabled", "on"
</code></pre>
<p>A false value can be represented like this:</p>
<pre><code>0, false, disabled, off, "false", "disabled", "off"
</code></pre>
<p><strong>NOTE</strong>: Cannot be represented by a raw string.
<strong>NOTE</strong>: In case of boolean values, parsing of identifiers and strings is case-insensitive.</p>
<h3 id="number"><a class="header" href="#number"><code>number</code></a></h3>
<p>Number values accept positive integers and floats. They cannot be expressed by idents or strings. Used for weights.</p>
<h3 id="style"><a class="header" href="#style"><code>Style</code></a></h3>
<p>Style properties tell Geo-AID how to display a given line or a circle. Available options are: <code>SOLID</code>, <code>DASHED</code>, <code>BOLD</code>, and <code>DOTTED</code>. They can be represented using identifiers or non-raw strings. When parsed, case is ignored.</p>
<h3 id="mathstring"><a class="header" href="#mathstring"><code>MathString</code></a></h3>
<p>MathString properties usually represent label contents. MathStrings are used to write normal text while also allowing lower indices and a restricted set of mathematical characters, like greek letters.</p>
<p><em>Parsing</em></p>
<p><strong>Identifiers</strong></p>
<p>If the identifier is a single character or a character code representing a letter (character codes explained below), a number of primes (also explained below), and a <code>_</code> followed by digits, it can be parsed as a MathString containing only that character.</p>
<p>Examples:</p>
<pre><code>A
B_12
C'
D''_456
</code></pre>
<p><strong>Raw strings</strong></p>
<p>Raw strings are parsed as a set of ASCII characters without any additional processing. Useful for injecting LaTeX into point labels, should it be necessary.</p>
<p>Examples:</p>
<pre><code>!"\mathbb{X}^\prime"
!"Hello, World!"
!"_{}}}Everything is literal}"
</code></pre>
<p><strong>Strings</strong></p>
<p>Strings are parsed like raw strings with a few important exceptions:</p>
<ul>
<li>Single quotes (<code>'</code>) are parsed as primes;</li>
<li>Everything directly after a <code>_</code>, until, but not including, a space, is parsed as being in lower index;</li>
<li>Lower index cannot be used inside a lower index;</li>
<li>Longer text with spaces can be put inside a lower index if delimited by braces (<code>{}</code>);</li>
<li>Text inside brackets (<code>[]</code>) is parsed as a character code and outputs a special character with that code;</li>
<li><code>\\</code> before a character inserts that character regardless of the above rules (it does not, however, enable using <code>"</code> in a string. You can use <code>[quote]</code> for that purpose).</li>
</ul>
<p>Examples:</p>
<pre><code>"A"
"B_12"
"C'_{Hello, World!}"
"[Alpha] [quote]label [alpha][quote]"
</code></pre>
<p><em>Character codes</em></p>
<p>Character codes are used to represent special characters. Currently, Geo-AID only supports greek letters - in form of the names of those letters, where the case of the first letter decides the case of the output letter - and quotes (<code>"</code>), written as <code>qoute</code>.</p>
<p><em>Primes</em></p>
<p>Primes, in MathStrings, are ticks often seen beside points. They are often used to represent a point after certain transformations, like symmetry or rotation (looks like <code>A'</code>). In MathStrings, all non-escaped (<code>\\</code>) single quotes (<code>'</code>) are treated as those.</p>
<h2 id="linetype"><a class="header" href="#linetype">LineType</a></h2>
<p><code>LineType</code> describes whether a line should be displayed as a continuous line, a ray or a segment. This property is allowed in a few functions. Possible values are: <code>LINE</code>, <code>RAY</code>, <code>SEGMENT</code>. The default depends on the context.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>Expression&lt;iter&gt;</em> :<br />
      <a href="reference/syntax/iterators.html"><em>ImplicitIterator</em></a><sub>only if <em>iter</em> = <code>true</code></sub><br />
   | <em>SimpleExpression</em><br />
   | <em>Expression&lt;iter&gt;</em> <em>BinOp</em> <em>Expression&lt;iter&gt;</em>;<br />
<br />
<em>BinOp</em> :<br />
   <code>+</code> | <code>-</code> | <code>*</code> | <code>/</code><br />
<br />
<em>SimpleExpression</em> :<br />
   <code>-</code><sup>?</sup> <em>SimpleExpressionKind</em> (<code>^</code> <em>Exponent</em>)<sup>?</sup> <em><a href="reference/syntax/properties.html">Properties</a></em><sup>?</sup><br />
<br />
<em>SimpleExpressionKind</em> :<br />
      <a href="reference/syntax/names.html">NAMES</a><br />
   | <a href="reference/syntax/numbers.html">NUMBER</a><br />
   | <em><a href="reference/syntax/iterators.html">ExplicitIterator</a></em><br />
   | <em>PointCollectionConstructor</em><br />
<br />
<em>UnOp</em> :<br />
   <code>-</code><br />
<br />
<em>Exponentiation</em> :<br />
   <em>SimpleExpressionKind</em> <code>^</code> <code>-</code><sup>?</sup> <em>Exponent</em><br />
<br />
<em>Exponent</em> :<br />
      <a href="reference/syntax/numbers.html">INTEGER</a><br />
   <code>(</code> <a href="reference/syntax/numbers.html">INTEGER</a> <code>/</code> <a href="reference/syntax/numbers.html">INTEGER</a> <code>)</code><br />
<br />
<em>PointCollectionConstructor</em> :<br />
   <code>&amp;</code> <code>(</code> <em>Expression&lt;false&gt;</em> (<code>,</code> <em>Expression&lt;false&gt;</em>)<sup>*</sup> <code>)</code></p>
</blockquote>
<p>Expressions represent all values in GeoScript. A simple example of an expression is a variable reference with the variable's value or a number literal. After most expressions display options can be given, modifying how the expression affects the final figure visually.</p>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<p>Names can also be used as expressions. See <a href="reference/syntax/names.html">here</a> for more details.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Binary operators all have the standard mathematical operation order. Unary operators always precede binary operators and implicit iterators always precede all operators. You can define your own order with parenthesis.</p>
<p>Currently, Geo-AID supports only addition, subtraction, multiplication and division as binary operators and negation as unary.</p>
<p>Weight in binary operations is applied to both of their operands. In unary operations, it is directly applied to their single operand.</p>
<h2 id="exponentiation"><a class="header" href="#exponentiation">Exponentiation</a></h2>
<p>Exponentiation takes precedence over every other operator, including negation. It can be written as <code>base^exp</code>, where <code>base</code> is the raised expression and <code>exp</code> is the exponent, either a literal integer or a fraction in the form <code>(nom / denom)</code> with <code>nom</code> and <code>denom</code> being integers and <code>denom</code> being nonzero. The exponent can also be negated by including a <code>-</code> in front of it (in case of fraction exponents, before the parenthesis).</p>
<p>When raising a value to a power, its unit is also raised.</p>
<p>Weights, like other properties are passed on to raised expressions.</p>
<h2 id="point-collections"><a class="header" href="#point-collections">Point Collections</a></h2>
<p>Expressions can also be used to construct point collections out of other expressions with <code>&amp;(A, B, ...)</code> syntax. All expressions inside must be convertible to points.</p>
<p>Weights on point collections are treated as though they were applied to each of the collected points.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="figure"><a class="header" href="#figure">Figure</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>Figure</em> :<br />
   <em>Statement</em><sup>*</sup><br />
<br />
<em>Statement</em> :<br />
      <em><a href="reference/syntax/flags.html">FlagStatement</a></em><br />
   | <em><a href="reference/syntax/variables.html">LetStatement</a></em><br />
   | <em><a href="reference/syntax/rules.html">RuleStatement</a></em><br />
   | <em><a href="reference/syntax/refs.html">RefStatement</a></em><br />
   | <code>;</code></p>
</blockquote>
<p>A <em>Figure</em> describes how a figure should be generated in terms of generator flags, variable definitions and rules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<blockquote>
<p><sup><strong>Lexer</strong></sup><br />
IDENT :<br />
      NAMED_IDENT<br />
   | POINT_COLLECTION<br />
<br />
NAMED_IDENT :<br />
   Start Continue<sup>*</sup><br />
<br />
POINT_COLLECTION :<br />
   (Point <code>'</code><sup>*</sup>)<sup>+</sup></p>
</blockquote>
<p>Where <code>Start</code> is any unicode character with the <em>Alphabetic</em> property or an underscore (<code>_</code>) character, <code>Continue</code> is <code>Start</code> or a tick (<code>'</code>) character and <code>Point</code> is any unicode character with the <em>Uppercase</em> property.</p>
<p>Identifiers mostly represent variables, though they may also serve as a rule operator, a function, a value for a display property or a flag value. See also: <a href="reference/syntax/names.html">names</a>.</p>
<p>Point collections are a special kind of identifiers. They essentially represent a sequence of variables, each being a point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>ImplicitIterator</em> :<br />
   <a href="reference/syntax/expressions.html"><em>Expression&lt;false&gt;</em></a> (<code>,</code> <a href="reference/syntax/expressions.html">
<em>Expression&lt;false&gt;</em></a>)<sup>+</sup><br />
<br />
<em>ExplicitIterator</em> :<br />
   <code>$</code> <a href="reference/syntax/numbers.html">INTEGER</a> <code>(</code> <a href="reference/syntax/expressions.html"><em>Expression&lt;false&gt;</em></a> (<code>,</code> <a href="reference/syntax/expressions.html">
<em>Expression&lt;false&gt;</em></a>)<sup>*</sup> <code>)</code></p>
</blockquote>
<p>Iterators can be used in <code>let</code> statements and rules on both sides. A sequence of expressions separated by a comma is
called an <em>implicit iterator</em>. Using these, multiple lines of a script can be collapsed into a single one. For example:</p>
<pre><code>let A, B, C = Point();

AB = AC, BC;
</code></pre>
<p>Iterators are expanded into multiple rules/statement by simply iterating over the given sequence. Implicit iterators
take precedence over any arithmetic operators. Here's a few examples:</p>
<pre><code>AB, BC = CD, EF;

# Becomes
AB = CD;
BC = EF;
</code></pre>
<pre><code>AB &lt; XY + YZ, OI;

# Becomes.
AB &lt; XY + YZ;
AB &lt; XY + OI;
</code></pre>
<p>whereas</p>
<pre><code>AB &lt; (XY + YZ), OI;

# Becomes

AB &lt; XY + YZ;
AB &lt; OI;
</code></pre>
<p>To use implicit iterators inside a function call, simply put parentheses around them: <code>intersection(AB, (KL, XY))</code></p>
<p>Another type of iterator is an <em>explicit iterator</em>. These are written in the following way:</p>
<pre><code>AB = $1(AC, BC);
</code></pre>
<p>The above example is equivalent to just writing</p>
<pre><code>AB = AC, BC;
</code></pre>
<p>The number after the dollar sign is the <em>id</em> of the iterator. If only a single id is used, they function just like
implicit iterators. However, when using multiple different ids, more complicated results can be achieved:</p>
<pre><code>$1(AB, CD) &lt; $2(XY, YZ);

# Becomes
AB &lt; XY;
CD &lt; XY;
AB &lt; YZ;
CD &lt; YZ;
</code></pre>
<p>Explicit iterators can also be nested, allowing for even more complicated rules. For example:</p>
<pre><code>$1(AB, BC) &gt; $1(x, $2(a, b)), $3(9, 4, 3);

# Becomes
AB &gt; x;
BC &gt; a;
BC &gt; b;
AB &gt; 9;
AB &gt; 4;
AB &gt; 3;
BC &gt; 9;
BC &gt; 4;
BC &gt; 3;
</code></pre>
<p>Iterators have a few rules. Not obeying them causes compilation errors.</p>
<ul>
<li>All implicit iterators have an id of 0;</li>
<li>All iterators of the same id must have the same length;</li>
<li>The left hand side of <code>let</code> statements only accept implicit iterators;</li>
<li>The right hand side of <code>let</code> statements accepts at most one level of iteration;</li>
<li>The right hand side of a <code>let</code> statement may only contain iterators, if so does the left side;</li>
<li>All iterators must have at least two variants;</li>
<li>An iterator with id x must not contain another iterator with id x;</li>
<li>Iterator length must not exceed 255;</li>
<li>Iterator id must be an integer;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="names-1"><a class="header" href="#names-1">Names</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>Name&lt;iter&gt;</em> :<br />
      <em><a href="reference/syntax/identifiers.html">IDENT</a></em><br />
   | <em>ExprCall</em><br />
   | <em>FieldIndex</em>;<br />
   | <code>(</code> <em><a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a></em> <code>)</code><br />
<br />
<em>ExprCall</em> :<br />
   <em>Name</em> <code>(</code> (<em><a href="reference/syntax/expressions.html">Expression&lt;false&gt;</a></em> (<code>,</code> <em><a href="reference/syntax/expressions.html">Expression&lt;false&gt;</a></em>)<sup>*</sup>)<sup>?</sup> <code>)</code>\</p>
</blockquote>
<h2 id="interpreting-names"><a class="header" href="#interpreting-names">Interpreting names</a></h2>
<p>Names can be interpreted in two ways: as values or as function references. When used as values, identifiers denote variable accesses, field indices represent accessing certain fields of values, parenthesised expressions represent the contained expressions and function calls are rather self-explanatory. When used as function references, idents represent global functions, field accesses represent methods and parenthesised expressions, like function calls, are not allowed.</p>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Identifiers denote variables created with <code>let</code> statements. When given weight to a named identifier, it will affect the weighing of the definition after expansion (the definition itself won't be affected). When a weight is given to a point collection, it will act as though it was given to each of the referenced points. Note, however, that since point collections are simply abstractions, there is no guarantee that each point of the collection will be used. It the vast majority of cases that can however be guaranteed.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Different types have different fields. You should seek specifics in the documentations of respective types. A field index has the following form: <code>name . field</code>. The name is expected to be a value.</p>
<p>Weights on field accesses are treated like on variables.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>The call syntax, <code>name(arg1, arg2, ...)</code> can be used to call functions with specified parameters. Functions, beyond being constructive expressions, can modify the visual output of the figure, e.g. add a line/ray. This behavior can be usually modified using display options. Some functions accept parameter groups, allowing infinite number of parameters. All functions return a single value. Implicit iterators cannot be used in function parameters, unless surrounded by parentheses.</p>
<p>The name of the function must be a function reference. If it's an ident, it's treated as a global function. If it's a field index, the function is treated like a method. Methods are special functions defined on types. They use that type as their first parameter, and are generally associated to that type. For specific examples, look at type documentations.</p>
<p>Weights given to function calls affect the parameters and the expression generated by the function.</p>
<h2 id="parentheses"><a class="header" href="#parentheses">Parentheses</a></h2>
<p>Putting expressions in parentheses allows for modifying the order of operations or allowing the use of explicit iterators in contexts, where it wouldn't be normally possible. They also allow using complex expressions as names. Weights applied to parenthesised expressions are applied to their contained expressions. Note, that sometimes applied weight to parenthesised expressions is the only way to apply weight to the entire expression (for example: binary operations).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<blockquote>
<p><sup><strong>Lexer</strong></sup><br />
NUMBER :<br />
      INTEGER<br />
   | FLOAT<br />
<br />
INTEGER :<br />
   Digit<sup>+</sup>
<br />
FLOAT :<br />
   INTEGER <code>.</code> Digit<sup>*</sup></p>
</blockquote>
<p>Where <em>Digit</em> is an ASCII digit (<code>0-9</code>). Either integers or decimals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties-1"><a class="header" href="#properties-1">Properties</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>Properties</em> :<br />
   <code>[</code> <em>Property</em> (<code>;</code> <em>Property</em>)<sup>*</sup> <code>]</code><br />
<br />
<em>Property</em> :<br />
   <a href="reference/syntax/identifiers.html">NAMED_IDENT</a> <code>=</code> <em>PropertyValue</em><br />
<br />
<em>PropertyValue</em> :<br />
      <a href="reference/syntax/numbers.html">NUMBER</a><br />
   | <a href="reference/syntax/identifiers.html">IDENT</a><br />
   | STRING<br />
   | <em>RawString</em><br />
<br />
<em>RawString</em> :<br />
   <code>!</code> STRING</p>
</blockquote>
<h2 id="property-values-1"><a class="header" href="#property-values-1">Property values</a></h2>
<h3 id="bool-1"><a class="header" href="#bool-1"><code>bool</code></a></h3>
<p>Boolean properties represent true or false for certain properties. A true value can be represented as the following:</p>
<pre><code>1, true, enabled, on, "true", "enabled", "on"
</code></pre>
<p>A false value can be represented like this:</p>
<pre><code>0, false, disabled, off, "false", "disabled", "off"
</code></pre>
<p><strong>NOTE</strong>: Cannot be represented by a raw string.
<strong>NOTE</strong>: In case of boolean values, parsing of identifiers and strings is case-insensitive.</p>
<h3 id="number-1"><a class="header" href="#number-1"><code>number</code></a></h3>
<p>Number values accept positive integers and floats. They cannot be expressed by idents or strings. Used for weights.</p>
<h3 id="style-1"><a class="header" href="#style-1"><code>Style</code></a></h3>
<p>Style properties tell Geo-AID how to display a given line or a circle. Available options are: <code>SOLID</code>, <code>DASHED</code>, <code>BOLD</code>, and <code>DOTTED</code>. They can be represented using identifiers or non-raw strings. When parsed, case is ignored.</p>
<h3 id="mathstring-1"><a class="header" href="#mathstring-1"><code>MathString</code></a></h3>
<p>MathString properties usually represent label contents. MathStrings are used to write normal text while also allowing lower indices and a restricted set of mathematical characters, like greek letters.</p>
<p><em>Parsing</em></p>
<p><strong>Identifiers</strong></p>
<p>If the identifier is a single character or a character code representing a letter (character codes explained below), a number of primes (also explained below), and a <code>_</code> followed by digits, it can be parsed as a MathString containing only that character.</p>
<p>Examples:</p>
<pre><code>A
B_12
C'
D''_456
</code></pre>
<p><strong>Raw strings</strong></p>
<p>Raw strings are parsed as a set of ASCII characters without any additional processing. Useful for injecting LaTeX into point labels, should it be necessary.</p>
<p>Examples:</p>
<pre><code>!"\mathbb{X}^\prime"
!"Hello, World!"
!"_{}}}Everything is literal}"
</code></pre>
<p><strong>Strings</strong></p>
<p>Strings are parsed like raw strings with a few important exceptions:</p>
<ul>
<li>Single quotes (<code>'</code>) are parsed as primes;</li>
<li>Everything directly after a <code>_</code>, until, but not including, a space, is parsed as being in lower index;</li>
<li>Lower index cannot be used inside a lower index;</li>
<li>Longer text with spaces can be put inside a lower index if delimited by braces (<code>{}</code>);</li>
<li>Text inside brackets (<code>[]</code>) is parsed as a character code and outputs a special character with that code;</li>
<li><code>\\</code> before a character inserts that character regardless of the above rules (it does not, however, enable using <code>"</code> in a string. You can use <code>[quote]</code> for that purpose).</li>
</ul>
<p>Examples:</p>
<pre><code>"A"
"B_12"
"C'_{Hello, World!}"
"[Alpha] [quote]label [alpha][quote]"
</code></pre>
<p><em>Character codes</em></p>
<p>Character codes are used to represent special characters. Currently, Geo-AID only supports greek letters - in form of the names of those letters, where the case of the first letter decides the case of the output letter - and quotes (<code>"</code>), written as <code>qoute</code>.</p>
<p><em>Primes</em></p>
<p>Primes, in MathStrings, are ticks often seen beside points. They are often used to represent a point after certain transformations, like symmetry or rotation (looks like <code>A'</code>). In MathStrings, all non-escaped (<code>\\</code>) single quotes (<code>'</code>) are treated as those.</p>
<h2 id="linetype-1"><a class="header" href="#linetype-1">LineType</a></h2>
<p><code>LineType</code> describes whether a line should be displayed as a continuous line, a ray or a segment. This property is allowed in a few functions. Possible values are: <code>LINE</code>, <code>RAY</code>, <code>SEGMENT</code>. The default depends on the context.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ref-statements"><a class="header" href="#ref-statements">Ref statements</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>RefStatement</em> :<br />
      <em><a href="reference/syntax/properties.html">Properties</a></em> <code>?</code> <em><a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a></em> <code>;</code></p>
</blockquote>
<p>Ref statements can be used to display expressions without any side effects.</p>
<h2 id="properties-of-refs"><a class="header" href="#properties-of-refs">Properties of refs</a></h2>
<p>If provided a non-zero <code>weight</code> property, a ref statement generates a <em>bias rule</em>. Bias rules are rules that are always true. They can be used to artificially make certain adjustables more stable. Beyond that, any display properties defined on them are treated like properties of the ref-ed expression.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rules"><a class="header" href="#rules">Rules</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>RuleStatement</em> :<br />
   <em><a href="reference/syntax/properties.html">Properties</a></em> <em><a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a></em> <em>RuleOp</em> <a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a>* <code>;</code><br />
<br />
<em>RuleOp</em> :<br />
      <code>&lt;</code> | <code>&lt;=</code> | <code>=</code> | <code>&gt;=</code> | <code>&gt;</code><br />
   | <a href="reference/syntax/identifiers.html">IDENT</a><br />
   | <code>!</code> <em>RuleOp</em></p>
</blockquote>
<p>Rules are the basic building blocks of a figure. They define relationships between figure objects. Geo-AID attempts to generate a figure that obeys them as good as it can. Rules tie two expressions (left and right hand side) with a relationship, otherwise known as the rule operator. Currently supported rule operators are all comparison operators. When given an identifier, a proper <em>defined rule operator</em> is looked up and compiled accordingly (currently none supported). Rules can also be inverted with an exclamation mark in front of the operator.</p>
<p>Weights on non-ident rules are assigned to them directly and end up being used directly in the generation process. Weights on ident rules are treated differently depending on the rule. You should seek documentation on them in docs for respective operators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-1"><a class="header" href="#variables-1">Variables</a></h1>
<blockquote>
<p><sup><strong>Syntax</strong></sup><br />
<em>LetStatement</em> :<br />
   <code>let</code> <em>VariableDefinition</em> (<code>,</code> <em>VariableDefinition</em>)<sup>*</sup> <code>=</code> <em><a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a></em> (<em><a href="reference/syntax/rules.html">RuleOp</a></em> <em><a href="reference/syntax/expressions.html">Expression&lt;true&gt;</a></em>)<sup>*</sup> <code>;</code><br />
<br />
<em>VariableDefinition</em> :<br />
   <a href="reference/syntax/identifiers.html">IDENT</a> <em><a href="reference/syntax/properties.html">Properties</a></em><sup>?</sup></p>
</blockquote>
<p>A let statement creates variables given on the left hand side. The lhs of the statement can contain multiple variables. In that, case if the rhs has no iteration, all variables will be set to the given definition (no the same value, though). If there is one level of iteration, all variables will get their respective definition. More levels of iteration are not allowed.</p>
<p>The rhs expression of the statement can either become the variable's definition or it can be unpacked onto a point collection. Point collection variables are invalid. A point collection may be used on the right hand side only if the identifier on the left is a point collection.</p>
<p>After each variable name there can be given properties that are later applied to the defining expression(s).</p>
<p>The let statement accepts rules after its right hand side. They behave as if the lhs was a sequence of variable accesses in a 0-id iterator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>GeoScript has two kinds of types: primitives and bundles.</p>
<p>Primitives - the points, lines, scalars and circles, are the building blocks of every value in GeoScript. Bundles, on the other hand, consist of multiple primitives.</p>
<p>The compiler is capable of performing some implicit conversions:</p>
<ul>
<li>Unknown-unit scalars (usually literals) can be converted into a scalar with a distance unit.</li>
<li>A point collection consisting of two points can be converted into a line or the distance between the two points, depending on the context.</li>
<li>A point collection of length one is always automatically converted into a point.</li>
<li>When performing multiplication/division over a scalar with a unit and a scalar with an unknown unit, the latter is automatically converted into a unit-less scalar (standard scalar in mathematics).</li>
<li>Any variable defined with an unknown-unit scalar is assumed to be unit-less.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<h2 id="scalar"><a class="header" href="#scalar">Scalar</a></h2>
<p>A scalar is a simple real value with a unit - a unit is a product of integer powers of simple units. The simple units are:</p>
<ul>
<li>Distance</li>
<li>Angle</li>
</ul>
<p>Any scalar, whose unit cannot be determined, is assumed to be unit-less. Scalars in this reference are denoted as <code>Scalar(&lt;unit&gt;)</code>.</p>
<p>Note: A literal will never be coerced to an angle, since that would introduce uncertainty whether it should be treated as given in radians or degrees. Instead, look for their respective functions.</p>
<h2 id="point"><a class="header" href="#point">Point</a></h2>
<p>A point is defined as a point on a Euclidean plane. Denoted as <code>Point</code>.</p>
<p>Points have two fields: <code>x</code> and <code>y</code>, denoting the respective coordinate values. Use them carefully, though, as there are no guarantees as to what values they might be.</p>
<h2 id="circle"><a class="header" href="#circle">Circle</a></h2>
<p>A circle is given a center and a radius. It is a set of points with the distance to its center equal to its radius. Denoted as <code>Circle</code>.</p>
<p>Circles have two fields: <code>center</code> and <code>radius</code>, both of which are self-explanatory.</p>
<h2 id="line"><a class="header" href="#line">Line</a></h2>
<p>A line is a line in Euclidean sense. Denoted as <code>Line</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bundle-types"><a class="header" href="#bundle-types">Bundle types</a></h1>
<p>Bundle types are zero-cost abstractions over primitives. There are two types of bundles: point collections and named bundles.</p>
<h2 id="point-collections-1"><a class="header" href="#point-collections-1">Point collections</a></h2>
<p>Point collections are simply ordered collections of points. It is never a separate entity, only an abstraction over a set of points. Denoted as <code>&lt;length&gt;-P</code>. If <code>&lt;length&gt;</code> is given as <code>0</code>, it means a collection of any length. Most functions that accept points as arguments, also accept point collections.</p>
<h2 id="named-bundles"><a class="header" href="#named-bundles">Named Bundles</a></h2>
<p>Named bundles are similar to structs in C. They have names and named fields of any type (accessible through <a href="reference/types/../syntax/names.html">field indexing</a>). Denoted with their unique names different from the names of any other type.</p>
<h3 id="segment"><a class="header" href="#segment">Segment</a></h3>
<pre><code>Segment {
    A: [Point](primitives.md#point),
    B: [Point](primitives.md#point)
}
</code></pre>
<p><code>Segment</code>s have two fields denoting their ends.</p>
<p><em>Methods</em></p>
<ul>
<li><code>len()</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/types/primitives.html">Scalar (distance)</a></p>
<p><strong>Returns</strong>: the distance <code>AB</code>.</p>
<p><strong>Displays</strong>: exactly what <code>dst</code> displays, except that the <code>draw_segment</code> property is <code>false</code> by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators-1"><a class="header" href="#operators-1">Operators</a></h1>
<p>Standard arithmetic operations - addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>) and division (<code>/</code>) are only allowed between scalars. Addition and subtraction must only be performed between scalars of the same unit, whereas multiplication and division can be done with any two scalars. The resulting unit will simply be a product of the operation. Beyond that, negation with the <code>-</code> operator can be performed on any scalar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<h2 id="angle"><a class="header" href="#angle"><code>angle</code></a></h2>
<ul>
<li><code>angle(ABC: 3-P)</code></li>
<li><code>angle(A: Point, B: Point, C: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#scalar">Scalar (angle)</a></p>
<p><strong>Returns</strong>: measurement of the angle <code>ABC</code></p>
<p><strong>Displays</strong>: the angle's arms.</p>
<p>The function accepts additional properties in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Angle {
    display_arms: bool, // Default: true,
    arms_type: LineType, // Default: SEGMENT
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_arms</code> decides whether the arms should be displayed and <code>arms_type</code> decides whether they should be segments, rays or lines. The assumed order for rays is <code>B -&gt; A</code> and <code>B -&gt; C</code>;</p>
<ul>
<li><code>angle(k: Line, l: Line)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#scalar">Scalar (angle)</a></p>
<p><strong>Returns</strong>: measurement of the angle between <code>k</code> and <code>l</code>. Which angle, depends on the order of the lines. For predictable outcome, the point versions are strongly recommended.</p>
<h2 id="bisector"><a class="header" href="#bisector"><code>bisector</code></a></h2>
<ul>
<li><code>bisector(AB: 2-P)</code></li>
<li><code>bisector(A: Point, B: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Line">Line</a></p>
<p><strong>Returns</strong>: a bisector of the segment <code>AB</code> - a perpendicular line passing through its center.</p>
<ul>
<li><code>bisector(ABC: 3-P)</code></li>
<li><code>bisector(A: Point, B: Point, C: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Line">Line</a></p>
<p><strong>Returns</strong>: a bisector of the angle <code>ABC</code> - a line between lines <code>AB</code> and <code>BC</code>, where each point is in the same distance from both of these lines.</p>
<p><strong>Displays</strong>: the angle's arms.</p>
<p>The function accepts additional properties in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bisector {
    display_arms: bool, // Default: true,
    arms_type: LineType, // Default: SEGMENT
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_arms</code> decides whether the arms should be displayed and <code>arms_type</code> decides whether they should be segments, rays or lines. The assumed order for rays is <code>B -&gt; A</code> and <code>B -&gt; C</code>;</p>
<ul>
<li><code>angle(k: Line, l: Line)</code></li>
</ul>
<h2 id="circle-1"><a class="header" href="#circle-1"><code>Circle</code></a></h2>
<ul>
<li><code>Circle(center: Point, radius: Scalar (distance))</code></li>
<li><code>circle(radius: Scalar (distance), center: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Circle">Circle</a></p>
<p><strong>Returns</strong>: a circle with the given <code>center</code> and <code>radius</code>.</p>
<ul>
<li><code>Circle()</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Circle">Circle</a></p>
<p><strong>Returns</strong>: a circle with an adjusted (free point) <code>center</code> and an adjusted (free scalar) <code>radius</code>.</p>
<h2 id="degrees"><a class="header" href="#degrees"><code>degrees</code></a></h2>
<ul>
<li><code>degrees(value: Scalar (no unit))</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (angle)</a></p>
<p><strong>Returns</strong>: an angle with the given measurement in degrees. Related: <a href="reference/functions.html#radians">radians</a></p>
<h2 id="dst"><a class="header" href="#dst"><code>dst</code></a></h2>
<ul>
<li><code>dst(AB: 2-P)</code></li>
<li><code>dst(A: Point, B: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (distance)</a></p>
<p><strong>Returns</strong>: the distance between points <code>A</code> and <code>B</code>.</p>
<p><strong>Displays</strong>: the segment <code>AB</code>.</p>
<p>The function accepts additional properties in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dst {
    display_segment: bool, // Default: true,
    style: Style, // Default: SOLID
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_segment</code> decides whether the segment should be displayed and <code>style</code> decides how it should be displayed.</p>
<ul>
<li><code>dst(P: Point, k: Line)</code></li>
<li><code>dst(k: Line, P: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (distance)</a></p>
<p><strong>Returns</strong>: the distance between point <code>P</code> and line <code>k</code>.</p>
<p><strong>Displays</strong>: the segment between <code>P</code> and its perpendicular projection onto <code>k</code>.</p>
<p>The function accepts additional properties in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dst {
    display_segment: bool, // Default: true,
    style: Style, // Default: DASHED
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_segment</code> decides whether the segment should be displayed and <code>style</code> decides how it should be displayed.</p>
<ul>
<li><code>dst(value: Scalar (no unit / distance))</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (angle)</a></p>
<p><strong>Returns</strong>: the value with a distance unit.</p>
<h2 id="intersection"><a class="header" href="#intersection"><code>intersection</code></a></h2>
<ul>
<li><code>intersection(k: Line, l: Line)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#point">Point</a></p>
<p><strong>Returns</strong>: intersection of lines <code>k</code> and <code>l</code>.</p>
<p><strong>Displays</strong>: By default doesn't display the point dot. Modifiable with properties.</p>
<p><strong>Note</strong>: <code>display_dot</code> property is not currently supported.</p>
<h2 id="mid"><a class="header" href="#mid"><code>mid</code></a></h2>
<p><strong>Note</strong>: The following functions allow any positive numbers of arguments.</p>
<ul>
<li><code>mid(v_1: Scalar (any unit u), v_2 Scalar (the same unit u), ..., v_n: Scalar (the same unit u))</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (the same unit u)</a></p>
<p><strong>Returns</strong>: The average value of <code>v_1</code>, <code>v_2</code>, ... <code>v_n</code>.</p>
<ul>
<li><code>mid(P_1: Point, P_2 Point, ..., P_n: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Point">Point</a></p>
<p><strong>Returns</strong>: The middle point of <code>P_1</code>, <code>P_2</code>, ... <code>P_n</code>. Special cases: when <code>n=2</code>, the middle of a segment; When <code>n=3</code>, the centroid of a triangle.</p>
<h2 id="parallel_through"><a class="header" href="#parallel_through"><code>parallel_through</code></a></h2>
<ul>
<li><code>parallel_through(P: Point, k: Line)</code></li>
<li><code>parallel_through(k: Line, P: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Line">Line</a></p>
<p><strong>Returns</strong>: a line parallel to <code>k</code>, passing through <code>P</code>.</p>
<h2 id="perpendicular_through"><a class="header" href="#perpendicular_through"><code>perpendicular_through</code></a></h2>
<ul>
<li><code>perpendicular_through(P: Point, k: Line)</code></li>
<li><code>perpendicular_through(k: Line, P: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Line">Line</a></p>
<p><strong>Returns</strong>: a line perpendicular to <code>k</code>, passing through <code>P</code>.</p>
<h2 id="point-1"><a class="header" href="#point-1"><code>Point</code></a></h2>
<ul>
<li><code>Point()</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Circle">Point</a></p>
<p><strong>Returns</strong>: an adjusted (free) point.</p>
<h2 id="radians"><a class="header" href="#radians"><code>radians</code></a></h2>
<ul>
<li><code>radians(value: Scalar (no unit))</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/primitives.html#Scalar">Scalar (angle)</a></p>
<p><strong>Returns</strong>: an angle with the given measurement in radians. Related: <a href="reference/functions.html#degrees">degrees</a></p>
<h2 id="segment-1"><a class="header" href="#segment-1"><code>Segment</code></a></h2>
<ul>
<li><code>Segment(AB: 2-P)</code></li>
<li><code>Segment(A: Point, B: Point)</code></li>
</ul>
<p><strong>Return type</strong>: <a href="reference/./types/bundle-types.html#segment">Segment</a></p>
<p><strong>Returns</strong>: the segment <code>AB</code>.</p>
<p><strong>Displays</strong>: the segment <code>AB</code>.</p>
<p>The function accepts additional properties in the form of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Segment {
    display_segment: bool, // Default: true,
    style: Style, // Default: SOLID
}
<span class="boring">}</span></code></pre></pre>
<p><code>display_segment</code> decides whether the segment should be displayed and <code>style</code> decides how it should be displayed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rule-operators"><a class="header" href="#rule-operators">Rule operators</a></h1>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>The operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> are only allowed between <a href="reference/./types/primitives.html#scalar">Scalars</a> of the same unit. They are simple comparison operators with their rules evaluated based on the relative difference between the two values.</p>
<p>The operator <code>=</code> (and its negation, <code>!=</code>) is allowed between <a href="reference/./types/primitives.html#scalar">Scalars</a> of the same unit and <a href="reference/./types/primitives.html#point">Points</a>. Its rule is evaluated based on the absolute distance between the two values.</p>
<h2 id="lies_on"><a class="header" href="#lies_on"><code>lies_on</code></a></h2>
<p>All uses accept <code>weight</code> property.</p>
<ul>
<li><code>P: Point lies_on k: Line</code></li>
</ul>
<p>Tells Geo-AID that point <code>P</code> lies on (has zero distance) from line <code>k</code>. Note: zero distance rules do not have any impact on the distance variable and decrease figure stability much less than other distance rules.</p>
<ul>
<li><code>P: Point lies_on k: Segment</code></li>
</ul>
<p>Tells Geo-AID that point <code>P</code> lies on (has zero distance) from the line of segment <code>k</code> and between its ends. Note: zero distance rules do not have any impact on the distance variable and decrease figure stability much less than other distance rules.</p>
<ul>
<li><code>P: Point lies_on omega: Circle</code></li>
</ul>
<p>Tells Geo-AID that point <code>P</code> lies on (has zero distance) from circle <code>omega</code>. Note: zero distance rules do not have any impact on the distance variable and decrease figure stability much less than other distance rules.</p>
<ul>
<li><code>col: 0-P lies_on omega: Circle</code></li>
</ul>
<p>Tells Geo-AID that points in the collection <code>col</code> lie on (have zero distance) from circle <code>omega</code> <em>in exactly the given order</em>. Note: zero distance rules do not have any impact on the distance variable and decrease figure stability much less than other distance rules.</p>
<p><strong>Note</strong>: When negated, creates rules for the points not to be on the circle. Points that are on the circle, just not in the given order will not satisfy this rule.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display-system"><a class="header" href="#display-system">Display system</a></h1>
<p>The display system decides which expressions are displayed and which are not. Its options are expressed through <a href="reference/syntax/properties.html">properties</a>.</p>
<h2 id="what-is-displayed"><a class="header" href="#what-is-displayed">What is displayed?</a></h2>
<p>Most expressions accept a <code>display</code> (<code>bool</code>) property, that has a default value based on the <em>constructive</em>-ness of the expression. Beyond that, expressions have a tree-like structure. For example, an expression representing an orthocenter of triangle ABC.</p>
<pre><code>intersection(perpendicular_through(AB, C), perpendicular_through(BC, A))
</code></pre>
<p>It's semantic structure is the following:</p>
<pre><code>- intersection
    - perpendicular_through
        - AB (line)
            - A
            - B
        - C
    - perpendicular_through
        - BC (line)
            - B
            - C
        - A
</code></pre>
<p>Now, the value of the <code>display</code> property of a node in that tree (e.g. the first <code>perpendicular_through</code>) decides not only whether the expression itself is displayed, but also whether its child nodes (the <code>AB</code> and <code>C</code> in our examples) are displayed.</p>
<p>Display properties are a simple sequence of key-value pairs used to modify how the figure should be displayed. They're accepted in expressions, rules and variable definitions. Display properties with invalid values or unexpected properties will cause an error and the ones with invalid names will be ignored.</p>
<p>The principle the display system works with is that <em>an expression is displayed by default iff it's constructive</em>.</p>
<h2 id="what-does-it-mean-to-display-an-expression"><a class="header" href="#what-does-it-mean-to-display-an-expression">What does it mean to display an expression?</a></h2>
<p>To display an expression means to display its visual representation in its final figure. As simple example, to display a <code>bisector(ABC)</code> is to add a line representing the bisector of the angle ABC to the output figure.</p>
<h2 id="what-is-a-constructive-expression"><a class="header" href="#what-is-a-constructive-expression">What is a constructive expression?</a></h2>
<p>A constructive expression is one that <em>constructs</em> a new object: a point, a line, etc. In practice, only variable references are non-constructive GeoScript - that is, referencing a variable either through a name or through a point collection won't display anything related to that variable (note that anything that could be displayed with it, should already be marked for display while processing the definition). It is however worth noting that point collection construction <em>is</em> constructive. Additionally, collections of length 2 <em>are</em> constructive, as they are converted to a different type (a line or a distance). Certain expressions, even though constructive, don't expect any properties simply because there's nothing to display. An example of that is a literal number.</p>
<h2 id="basic-properties-for-types"><a class="header" href="#basic-properties-for-types">Basic properties for types</a></h2>
<p>All <a href="reference/./types.html">types</a> have their basic properties assigned to them. These are the following.</p>
<p><em><code>Point</code></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Properties {
    display: bool, // Default: true
    label: MathString, // Default: empty (except look at next section)
    display_label: bool, // Default: true
    display_dot: bool // Default: true
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>display</code> property decides whether the point should be displayed. <code>label</code> gives the point a label and <code>display_label</code> decides if it is to be displayed. If <code>display_dot</code> is <code>true</code>, a small dot is displayed in the point's position.</p>
<p><strong>NOTE</strong>: <code>display_dot</code> has currently no effect and the dot is always displayed.
<strong>NOTE</strong>: Labels currently have poor support in SVG.</p>
<p><em><code>Line</code></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Line {
    display: bool, // Default: true,
    label: MathString, // Default empty (look at next section),
    display_label: bool, // Default: true
    style: Style, // Default: SOLID
}
<span class="boring">}</span></code></pre></pre>
<p><code>display</code>, <code>label</code> and <code>display_label</code> work like with points. The <code>style</code> property decides how the line should be displayed (what "brush" should be used).</p>
<p><strong>NOTE</strong>: Labels don't currently work with lines.</p>
<p><em><code>Circle</code></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Circle {
    display: bool, // Default: true,
    label: MathString, // Default empty (look at next section),
    display_label: bool, // Default: true
    style: Style, // Default: SOLID
}
<span class="boring">}</span></code></pre></pre>
<p><code>display</code>, <code>label</code>, <code>display_label</code> and <code>style</code> work like with lines.</p>
<p><strong>NOTE</strong>: Labels don't currently work with circles.</p>
<p><em><code>Scalar</code></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Scalar {
    display: bool, // Default: true,
    label: MathString, // Default empty (look at next section)
    display_label: Style, // Default: SOLID
}
<span class="boring">}</span></code></pre></pre>
<p>All properties work like described before.</p>
<p><strong>NOTE</strong>: Labels don't currently work with scalars.</p>
<p><em><code>PointCollection</code></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PointCollection {
    display: bool // Default: true
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>display</code> property works as usual.</p>
<p>Point collections also have special behavior when they are used in the context of lines or distances (see: <a href="reference/types.html">conversions</a>). Specifically, when converted to a distance measurement or a line, they also accept properties related to <code>Line</code>s (see above).</p>
<p><em><code>Bundle</code></em></p>
<p>All bundle types accept a <code>display</code> property.</p>
<hr />
<p>Variables and literals don't accept any properties, no matter the type. Beyond that, additional properties may be added depending on the kind of construction (used function). Details on those are in the documentation of respective functions.</p>
<h2 id="properties-on-variable-definitions"><a class="header" href="#properties-on-variable-definitions">Properties on variable definitions</a></h2>
<p>Variable definitions display their defining expressions. Properties defined on definitions are passed onto the expression. Additionally, if no label is given, the variable name is parsed as a MathString and used as a label if the parse was successful (and if there is no <code>display_label=false</code>).</p>
<h2 id="properties-on-rules"><a class="header" href="#properties-on-rules">Properties on rules</a></h2>
<p>Currently, rules only accept a <code>display</code> property and display both of their sides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weight-system"><a class="header" href="#weight-system">Weight system</a></h1>
<p>The weight system of Geo-AID is one of the core mechanisms of its generator. It directly modifies how much each adjustable will be affected by certain rules.</p>
<h2 id="how-are-weights-computed"><a class="header" href="#how-are-weights-computed">How are weights computed?</a></h2>
<p>Every entity present in a rule gets assigned a weight - by default equal to 1. Weights themselves, however, ultimately only apply to adjustables - values adjusted by the generator in the figure creation process. The weight system applies only to rules as they are the main set of instructions on how to generate a figure. Let's take a look at an example:</p>
<pre><code>let A, B, C = Point();

AC = BC;
</code></pre>
<p>The above script is a simple description of an isosceles triangle. In order to understand weights, we must first understand adjustables.</p>
<p>Adjustables are values adjusted by the generator - this means free points, free scalars, points on lines, etc. An example of a function generating an adjustable is the <code>Point()</code> function. It creates a free point able to be adjusted in both dimensions. Here, we generate three different free points. One for each of <code>A</code>, <code>B</code>, and <code>C</code>.</p>
<p>After the definition there is a single rule: <code>AB = BC</code>. As you can see, there are three adjustables here: <code>A</code>. <code>B</code>, <code>C</code>. Despite <code>B</code> appears twice, all adjustables get the same weight of 1.</p>
<h2 id="how-are-weights-applied"><a class="header" href="#how-are-weights-applied">How are weights applied?</a></h2>
<p>By the time weight computation has finished, each rule has a weight assigned to each adjustable in the figure specifying how much the rule affects the adjustable.</p>
<p>When it is all computed, each weight of the latter set of weights is <em>normalized</em>, that is: squeezed into the range <code>[0, 1]</code> by dividing each weight by the sum of them all. Finally, each weight is multiplied by the rule's assigned weight. This way each adjustable has a weight assigned to each rule.</p>
<p>When rules are evaluated, they are given a quality in range <code>[0, 1]</code>.  This way, for each adjustable, all values can be put into pairs <code>(quality, weight)</code> for each rule. From that a weighed mean is calculated (sum of the products <code>quality * weight</code> divided by the sum of weights). The result is the final quality of an adjustable.</p>
<p>The final quality affects how much an adjustable is adjusted when making corrections.</p>
<p>In short, rule weights affect how much a given adjustable is affected by the rule's quality in comparison to other rules.</p>
<h2 id="how-to-modify-weights"><a class="header" href="#how-to-modify-weights">How to modify weights?</a></h2>
<p>In general, weights are modified by adding a <code>number</code>-type <code>weight</code> property in square brackets:</p>
<pre><code>[weight = 2]
AB = BC;
</code></pre>
<p>Specifics regarding how do weight properties affect certain rules are in their respective documentations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math-behind-geo-aid"><a class="header" href="#math-behind-geo-aid">Math behind Geo-AID</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
